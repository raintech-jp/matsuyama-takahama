import{x as r,a1 as h,n as b,aS as C,v as S,ay as x,aT as m,aU as k,aV as y,aW as N,A as d,aX as i,ab as l,ax as f}from"./KCnrfC3l.js";const W=r({class:[String,Array,Object],style:{type:[String,Array,Object],default:null}},"component");function H(e){const s=h("useRender");s.render=e}const D=r({tag:{type:String,default:"div"}},"tag"),P=r({defaults:Object,disabled:Boolean,reset:[Number,String],root:[Boolean,String],scoped:Boolean},"VDefaultsProvider"),$=b(!1)({name:"VDefaultsProvider",props:P(),setup(e,s){let{slots:n}=s;const{defaults:t,disabled:a,reset:o,root:u,scoped:g}=C(e);return S(t,{reset:o,root:u,scoped:g,disabled:a}),()=>{var c;return(c=n.default)==null?void 0:c.call(n)}}});function v(e){return x(()=>{const s=[],n={};if(e.value.background)if(m(e.value.background)){if(n.backgroundColor=e.value.background,!e.value.text&&k(e.value.background)){const t=y(e.value.background);if(t.a==null||t.a===1){const a=N(t);n.color=a,n.caretColor=a}}}else s.push(`bg-${e.value.background}`);return e.value.text&&(m(e.value.text)?(n.color=e.value.text,n.caretColor=e.value.text):s.push(`text-${e.value.text}`)),{colorClasses:s,colorStyles:n}})}function R(e,s){const n=d(()=>({text:i(e)?e.value:s?e[s]:null})),{colorClasses:t,colorStyles:a}=v(n);return{textColorClasses:t,textColorStyles:a}}function V(e,s){const n=d(()=>({background:i(e)?e.value:s?e[s]:null})),{colorClasses:t,colorStyles:a}=v(n);return{backgroundColorClasses:t,backgroundColorStyles:a}}const j=r({height:[Number,String],maxHeight:[Number,String],maxWidth:[Number,String],minHeight:[Number,String],minWidth:[Number,String],width:[Number,String]},"dimension");function p(e){return{dimensionStyles:d(()=>{const n={},t=l(e.height),a=l(e.maxHeight),o=l(e.maxWidth),u=l(e.minHeight),g=l(e.minWidth),c=l(e.width);return t!=null&&(n.height=t),a!=null&&(n.maxHeight=a),o!=null&&(n.maxWidth=o),u!=null&&(n.minHeight=u),g!=null&&(n.minWidth=g),c!=null&&(n.width=c),n})}}const w=r({rounded:{type:[Boolean,Number,String],default:void 0},tile:Boolean},"rounded");function T(e){let s=arguments.length>1&&arguments[1]!==void 0?arguments[1]:f();return{roundedClasses:d(()=>{const t=i(e)?e.value:e.rounded,a=i(e)?e.value:e.tile,o=[];if(t===!0||t==="")o.push(`${s}--rounded`);else if(typeof t=="string"||t===0)for(const u of String(t).split(" "))o.push(`rounded-${u}`);else(a||t===!1)&&o.push("rounded-0");return o})}}const A=r({border:[Boolean,Number,String]},"border");function I(e){let s=arguments.length>1&&arguments[1]!==void 0?arguments[1]:f();return{borderClasses:d(()=>{const t=i(e)?e.value:e.border,a=[];if(t===!0||t==="")a.push(`${s}--border`);else if(typeof t=="string"||t===0)for(const o of String(t).split(" "))a.push(`border-${o}`);return a})}}const O=r({elevation:{type:[Number,String],validator(e){const s=parseInt(e);return!isNaN(s)&&s>=0&&s<=24}}},"elevation");function E(e){return{elevationClasses:d(()=>{const n=i(e)?e.value:e.elevation,t=[];return n==null||t.push(`elevation-${n}`),t})}}export{$ as V,D as a,A as b,w as c,I as d,T as e,j as f,O as g,p as h,E as i,R as j,v as k,V as l,W as m,H as u};
